/ WORK IN PROGRESS
:javascript
  $(document).ready(function(){
    $('form').on('click', '.remove_fields', function(event) {
      $(this).closest('.field').remove();
      event.preventDefault();
    });

    $('form').on('click', '.add_fields', function(event) {
      var regexp, time;
      time = new Date().getTime();
      regexp = new RegExp($(this).data('id'), 'g');
      $(this).closest('.more').before($(this).data('fields').replace(regexp, time));
      event.preventDefault();
    });
  });

.well
  = search_form_for @q, url: adv_search_path, html: {method: :post } do |f|
    .form-inline.form-group
      %strong Match #{f.combinator_select({}, class: 'form-control')} conditions
    = f.condition_fields do |c|
      = render 'condition_fields', f: c
    .more.btn-group
      = link_to_add_fields 'Add Condition', f, :condition
      = f.submit 'Search', class: 'btn btn-default'
      = link_to 'Reset', request.path, class: 'btn btn-default'
%hr

/ borrowed from index
/ TODO: refactor
:ruby
  query = params[:query]
  params = request.params.except(:authenticity_token, :action, :controller, :utf8, :bulk_export, :_pjax)
  params.delete(:query) if params[:query].blank?
  params.delete(:sort_reverse) unless params[:sort_reverse] == 'true'
  sort_reverse = params[:sort_reverse]
  sort = params[:sort]
  params.delete(:sort) if params[:sort] == @model_config.list.sort_by.to_s
  export_action = RailsAdmin::Config::Actions.find(:export, { controller: self.controller, abstract_model: @abstract_model })
  export_action = nil unless export_action && authorized?(export_action.authorization_key, @abstract_model)
  description = RailsAdmin.config(@abstract_model.model_name).description
  properties = @model_config.list.with(controller: self.controller, view: self, object: @abstract_model.model.new).visible_fields
  # columns paginate
  sets = get_column_sets(properties)
  properties = sets[params[:set].to_i] || []
  other_left = ((params[:set].to_i - 1) >= 0) && sets[params[:set].to_i - 1].present?
  other_right = sets[params[:set].to_i + 1].present?

%style
  - properties.select{ |p| p.column_width.present? }.each do |property|
    = "#list th.#{property.css_class} { width: #{property.column_width}px; min-width: #{property.column_width}px; }"
    = "#list td.#{property.css_class} { max-width: #{property.column_width}px; }"

- content_for :contextual_tabs do
  = bulk_menu
#list
  = form_tag bulk_action_path(model_name: @abstract_model.to_param), method: :post, id: "bulk_form", class: "form" do
    = hidden_field_tag :bulk_action
    - if description.present?
      %p
        %strong= description
    .table-responsive
      %table.table.table-condensed.table-hover
        %thead
          %tr
            %th.shrink
              %input.toggle{type: "checkbox"}
            - if other_left
              %th.other.left.shrink= "..."
            - properties.each do |property|
              - selected = (sort == property.name.to_s)
              - if property.sortable
                - sort_location = adv_search_path params.except('sort_reverse').except('page').merge(sort: property.name).merge(selected && sort_reverse != "true" ? {sort_reverse: "true"} : {})
                - sort_direction = (sort_reverse == 'true' ? "headerSortUp" : "headerSortDown" if selected)
              %th{class: "#{property.sortable && "header pjax" || nil} #{sort_direction if property.sortable && sort_direction} #{property.css_class} #{property.type_css_class}", :'data-href' => (property.sortable && sort_location), rel: "tooltip", title: "#{property.hint}"}= capitalize_first_letter(property.label)
            - if other_right
              %th.other.right.shrink= "..."
            %th.last.shrink
        %tbody
          - @objects.each do |object|
            %tr{class: "#{@abstract_model.param_key}_row"}
              %td
                = check_box_tag "bulk_ids[]", object.id, false
              - if @other_left_link ||= other_left && index_path(params.except('set').merge(params[:set].to_i != 1 ? {set: (params[:set].to_i - 1)} : {}))
                %td.other.left= link_to "...", @other_left_link, class: 'pjax'
              - properties.map{ |property| property.bind(:object, object) }.each do |property|
                - value = property.pretty_value
                %td{class: "#{property.css_class} #{property.type_css_class}", title: strip_tags(value.to_s)}= value
              - if @other_right_link ||= other_right && index_path(params.merge(set: (params[:set].to_i + 1)))
                %td.other.right= link_to "...", @other_right_link, class: 'pjax'
              %td.last.links
                %ul.inline.list-inline= menu_for :member, @abstract_model, object, true

    - if @objects.respond_to?(:total_count)
      - total_count = @objects.total_count.to_i
      .row
        .col-md-6= paginate(@objects, theme: 'ra-twitter-bootstrap', remote: true)
        / This is different than index
        .col-md-6.text-right= link_to(t("admin.misc.show_all"), adv_search_path(params.merge(all: true)), class: "show-all btn btn-default clearfix pjax") unless total_count > 100 || total_count <= @objects.to_a.size
      = page_entries_info @objects, entry_name: @model_label_plural
    - else
      .clearfix.total-count= "Displaying all <strong>#{@objects.size}</strong> #{@model_config.pluralize(@objects.size).downcase}".html_safe
